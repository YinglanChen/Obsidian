import "resources/sample_programs/pilot2//betting_utils.obs"
import "resources/sample_programs/pilot2/games.obs"


// asset contract Money {
//     int amount;

//     Money@Owned(int amt) {
//         amount = amt;
//     }

//     transaction mergeMoney(Money@Owned this, Money@Owned >> Unowned m) {
//          amount = amount + m.getAmount();
//          disown m;
//     }

//     transaction getAmount(Money@Owned this) returns int {
//         return amount;
//     }

//     transaction splitMoney(Money@Owned this, int amt) returns Money@Owned {
//         if (amt > amount) {
//             revert "Can't split out more money than is available in a given Money object.";
//         } else {
//             amount = amount - amt;
//             return new Money(amt);
//         }
//     }
// }

// contract Prediction {
//     string predictedWinner;
//     int bettorId;
//     int betAmount;

//     Prediction@Owned(int id, string predWin, int amount) {
//         bettorId = id;
//         predictedWinner = predWin;
//         betAmount = amount;
//     }

//     transaction getPrediction(Prediction@Unowned this) returns string {
//         return predictedWinner;
//     }
    
//     transaction getBettorId(Prediction@Unowned this) returns int {
//         return bettorId;
//     }

//     transaction getBetAmount(Prediction@Unowned this) returns int {
//         return betAmount;
//     }
// }

// contract PredictionList {
//     state Empty;
//     state HasItems {
//         PredictionList@Shared next;
//         Prediction@Unowned pred;
//     }

//     PredictionList@Empty() {
//         ->Empty;
//     }

//     transaction getNext(PredictionList@HasItems this) returns PredictionList@Shared {
//         return next;
//     }

//     transaction getValue(PredictionList@HasItems this) returns Prediction@Unowned {
//         return pred;
//     }

//     transaction append(Prediction@Unowned p) {
        
//         if (this in Empty) {
//             PredictionList pList = new PredictionList();
//             -> HasItems(pred = p, next = pList);
//         }
//         else {
//             next.append(p);
//         }
//     }

//     transaction popBack(PredictionList@HasItems >> (Empty | HasItems) this) returns Prediction@Unowned {
//         if (next in Empty) {           
//             Prediction temp = pred;           
//             disown next;
//             ->Empty;
//             return temp;
//         }
//         else {
//             popBack();
//         }
//         revert; //should never get here
//     }

//     transaction popSpecific(int givenId) returns Prediction@Unowned {
//         if (this in HasItems) {
//             if (pred.getBettorId() == givenId) {
//                 Prediction temp = pred; 
//                 if (next in Empty) {                   
//                     disown next;
//                     ->Empty;
//                 }
//                 else {
//                     Prediction newP = next.getValue();
//                     PredictionList pList = next.getNext();
//                     -> HasItems(pred = newP, next = pList);
//                 }
//                 return temp;
//             }
//             else {
//                 return next.popSpecific(givenId);
//             }
//         }
//         else {
//             revert("No bettors in list");
//         }
//     }

//     transaction contains(int id) returns bool {
//         if (this in HasItems) {
//             if (pred.getBettorId() == id) {
//                 return true;
//             }
//             else {
//                 return next.contains(id);
//             }
//         }
//         else {
//             return false;
//         }
//     }
// }

// asset contract Bettor {
//     Money@Owned money;
//     int id;

//     Bettor@Owned(int i) {
//         money = new Money(100);
//         id = i;
//     }

//     transaction getID(Bettor@Unowned this) returns int {
//         return id;
//     }
    
//     transaction withdrawMoney(Bettor@Owned this, int amount) returns Money@Owned {
//         Money m = money.splitMoney(amount);
//         return m;
//     }

//     transaction receiveMoney(Bettor@Unowned this, Money@Owned >> Unowned m) {
//         money.mergeMoney(m);
//     }
// }

// contract BettorList {
//     state Empty;
//     state HasItems {
//         BettorList@Shared next;
//         Bettor@Unowned b;
//     }

//     BettorList@Empty() {
//         ->Empty;
//     }

//     transaction getNext(BettorList@HasItems this) returns BettorList@Shared {
//         return next;
//     }

//     transaction getValue(BettorList@HasItems this) returns Bettor@Unowned {
//         return b;
//     }

//     transaction append(Bettor@Unowned newB) {
        
//         if (this in Empty) {
//             BettorList bList = new BettorList();
//             -> HasItems(b = newB, next = bList);
//         }
//         else {
//             next.append(newB);
//         }
//     }

//     transaction popBack(BettorList@HasItems >> (Empty | HasItems) this) returns Bettor@Unowned {
//         if (next in Empty) {           
//             Bettor temp = b;           
//             disown next;
//             ->Empty;
//             return temp;
//         }
//         else {
//             popBack();
//         }
//         revert; //Should never get here
//     }

//     transaction popSpecific(int givenId) returns Bettor@Unowned {
//         if (this in HasItems) {
//             if (b.getID() == givenId) {
//                 Bettor temp = b; 
//                 if (next in Empty) {                   
//                     disown next;
//                     ->Empty;
//                 }
//                 else {
//                     Bettor newB = next.getValue();
//                     BettorList bList = next.getNext();
//                     -> HasItems(b = newB, next = bList);
//                 }
//                 return temp;
//             }
//             else {
//                 return next.popSpecific(givenId);
//             }
//         }
//         else {
//             revert("No bettors in list");
//         }
//     }

//     transaction contains(int id) returns bool {
//         if (this in HasItems) {
//             if (b.getID() == id) {
//                 return true;
//             }
//             else {
//                 return next.contains(id);
//             }
//         }
//         else {
//             return false;
//         }
//     }
// }

// contract Player {
//     string move;

//     Player@Owned() {
//         move = "none";
//     }

//     transaction getMove(Player@Owned >> Owned this) returns string {
//         return move;
//     }

//     transaction setMove(Player@Owned >> Owned this, string newMove) {
//         move = newMove;
//     }
// }

// contract Game {
//     Player@Owned p1;
//     Player@Owned p2;
//     //...

//     state Start;
//     state Playing;
//     state FinishedPlaying;

//     Game@Start() {
//         p1 = new Player();
//         p2 = new Player();
//         //...
//         -> Start;
//     }

//     transaction play(Game@Start >> Playing this) {
//         //...
//         -> Playing;
//     }

//     //Returns the winner of the game
//     transaction calculateWinner(Game@Playing >> FinishedPlaying this) returns string {
//         //...
//         -> FinishedPlaying;
//         return "";
//     }

// }

// main asset contract Casino {

//     Game@Start game;
//     Money@Owned money;
//     PredictionList@Shared predictions;
//     BettorList@Shared bettors;

//     state AcceptingBets;
//     state PlayingGame;
//     state GivePayout {
//         string winner;
//     };

//     Casino@Owned() {
//         game = new Game();
//         money = new Money(100000);
//         predictions = new PredictionList();
//         bettors = new BettorList();
//         -> AcceptingBets;
//     }

//     transaction makeBet(Casino@AcceptingBets this, Bettor@Unowned b, Money@Owned >> Unowned m, string predictedWinner) {
//         int betAmount = m.getAmount();
//         money.mergeMoney(m);
//         Prediction p = new Prediction(b.getID(), predictedWinner, betAmount);
//         if (predictions.contains(b.getID())) {
//             Prediction pred = predictions.popSpecific(b.getID());
//             int amountToReturn = pred.getBetAmount();
//             Money m = money.splitMoney(amountToReturn);
//             b.receiveMoney(m);
//         }
//         else {
//             bettors.append(b);
//         }
//         predictions.append(p);       
//     }

//     transaction closeBetting(Casino@AcceptingBets >> PlayingGame this) {
//         -> PlayingGame;
//     }

//     //This function will be different for every game
//     transaction playGame(Casino@PlayingGame >> GivePayout this) {
//         game.play();
//         string win = game.calculateWinner();
//         -> GivePayout(winner = win);
//     }

//     transaction returnMoney(Casino@GivePayout this, Bettor@Unowned b) {
//         int bettorID = b.getID();
//         try {
//             Bettor temp = bettors.popSpecific(bettorID); //This will fail if the bettor has not made a bet
//         }
//         catch {
//             revert "Bettor has not made a bet";
//         }
//         Prediction p = predictions.popSpecific(bettorID);
//         if (p.getPrediction() == winner) {
//             int amountToReturn = p.getBetAmount() * 2;
//             Money m = money.splitMoney(amountToReturn);
//             b.receiveMoney(m);

//         }
//         //If prediction wrong, no money returned
//     }

//     transaction resetBetting() {
//         -> AcceptingBets;
//     }
// }

main asset contract Casino {

    Money@Owned money;
    GameRecordList@Shared gamerecords;

    Casino@Owned() {
        money = new Money(100000);
        gamerecords = new GameRecordList();
    }

    transaction makeBet(Casino@Owned this, Bettor@Unowned b, Money@Owned >> Unowned m, Player@Unowned predictedWinner, Game@Unowned g) {
        if (g in Playing) {
            revert("Cannot make bet");
        }
        int betAmount = m.getAmount();
        money.mergeMoney(m);
        Prediction p = new Prediction(predictedWinner, betAmount);
        Bet bet = new Bet(b, p);
        if (gamerecords.contains(g)) {
            GameRecord gr = gamerecords.popSpecific(g);
            BetList bets = gr.getBets();
            if (bets.contains(b)) {
                Prediction pred = bets.popSpecific(b).getPrediction();
                int amountToReturn = pred.getBetAmount();
                Money m = money.splitMoney(amountToReturn);
                b.receiveMoney(m);
            }
            bets.append(bet);
        }
        else {
            revert("cannot bet on this game");
        }
        
    }

    transaction returnMoney(Casino@Owned this, Bettor@Unowned b, Game@Owned g) {
        if (!gamerecords.contains(g)) {
            revert("game doesn't exist");
        }
        if (g in FinishedPlaying) {
            GameRecord gr = gamerecords.popSpecific(g);
            if (!gr.getBets().contains(b)) {
                revert("Bettor didn't make a bet");
            }
            Bet temp = gr.getBets().popSpecific(b);
            Prediction p = temp.getPrediction();
            if (p.getPrediction() == g.calculateWinner()) {
                int amountToReturn = p.getBetAmount() * 2;
                Money m = money.splitMoney(amountToReturn);
                b.receiveMoney(m);

            }
            //If prediction wrong, no money returned
        }
        else {
            revert("cannot return money while game still going on");
        }
        
    }
}