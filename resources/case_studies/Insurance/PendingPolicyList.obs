import "resources/case_studies/Insurance/PolicyRecord.obs"

contract NodeMaybe {

    NodeMaybe@Some(PendingPolicyNode@Shared node) {
        ->Some(node = node);
    }

    NodeMaybe@None() {
        ->None;
    }

    state Some {
        PendingPolicyNode@Shared node;
    }

    transaction getNode(NodeMaybe@Some this) returns PendingPolicyNode@Shared {
        return node;
    }

    transaction getValue(NodeMaybe@Some this) returns PolicyRecord@Unowned {
        return node.getValue();
    }

    state None {}
}

resource contract PendingPolicyNode {
    PolicyRecord@Pending elem;
    NodeMaybe@Owned next;

    PendingPolicyNode@Owned(PolicyRecord@Pending >> Unowned elem, NodeMaybe@Owned next) {
        this.elem = elem;
        this.next = next;
    }

    transaction setNext(NodeMaybe@Owned >> Unowned newNext) {
        next = newNext;
    }

    transaction getValue() returns PolicyRecord@Unowned {
        PolicyRecord@Pending elemCopy = elem;
        elem = elemCopy;
        return elemCopy;
    }

    transaction getValueOwned() returns PolicyRecord@Pending {
        PolicyRecord@Pending elemCopy = elem;
        elem = new PolicyRecord(elem.getPolicy(), new Money(0));
        return elemCopy;
    }

    transaction length() returns int {
        int i = 1;
        switch next {
            case Some {
                i = i + next.getNode().length();
            }
        }
        return i;
    }

    transaction nth(int n) returns NodeMaybe@Owned {
        if (n == 0) {
            return new NodeMaybe(this);
        }

        NodeMaybe@Owned ret;
        switch next {
            case Some {
                ret = next.getNode().nth(n - 1);
            }
            case None {
                ret = new NodeMaybe();
            }
        }

        return ret;
    }

    transaction append(PolicyRecord@Pending >> Unowned new_elem) {
        switch next {
            case Some {
                next.getNode().append(new_elem);
            }
            case None {
                next = new NodeMaybe(new PendingPolicyNode(new_elem, new NodeMaybe()));
            }
        }
    }

    // remove policy record that has the given policy
    transaction remove(Policy policy, PendingPolicyNode@Shared prevNode) returns PolicyRecord@Pending {
        PolicyRecord@Pending removed;

        if (elem.equals(policy)) {
            prevNode.setNext(next);
            removed = getValueOwned();
        } else {
            switch next {
                case Some {
                    removed = next.getNode().remove(policy, this);
                }

                case None {
                    throw; // TODO : element not in list?
                }
            }

        }

        return removed;

    }

    transaction equals(Policy policy) returns bool {
        return elem.equals(policy);
    }

}

main contract PendingPolicyList {

    NodeMaybe@Owned first;

    PendingPolicyList@Shared() {
        first = new NodeMaybe();
    }

    transaction length() returns int {
        int i = 0;
        switch first {
            case Some {
                i = first.getNode().length();
            }
        }
        return i;
    }

    transaction nth(int n) returns NodeMaybe {
        NodeMaybe@Owned node;
        switch first {
            case Some {
                node = first.getNode().nth(n);
            }
            case None {
                node = new NodeMaybe();
            }
        }
        return node;
    }

    transaction append(PolicyRecord@Pending >> Unowned elem) {
        switch first {
            case Some {
                first.getNode().append(elem);
            }
            case None {
                first = new NodeMaybe(new PendingPolicyNode(elem, new NodeMaybe()));
            }
        }
    }

    // remove and return the policy record that has the given policy
    transaction remove(Policy policy) returns PolicyRecord@Pending {
        PolicyRecord@Pending removed;

        switch first {
            case Some {
                PendingPolicyNode@Shared node = first.getNode();

                if(node.equals(policy)) {
                    first = new NodeMaybe();
                    removed = node.getValueOwned();
                } else {
                    removed = node.remove(policy, node);
                }
            }
            case None {
                throw; //TODO : element not in list?
            }
        }

        return removed;

    }

}
