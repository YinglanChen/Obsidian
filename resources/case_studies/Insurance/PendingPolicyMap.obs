import "resources/case_studies/Insurance/PolicyRecord.obs"

// This implements a mutable linked list of pending policies.
resource contract PendingPolicyList {
    state HasNext {
        Policy@Unowned key;
        PolicyRecord@Pending val;
        PendingPolicyList@Owned next;
    }

    state Empty {
    }

    PendingPolicyList@Empty() {
        ->Empty;
    }

    private transaction setNext(PendingPolicyList@HasNext this, PendingPolicyList@Owned >> Unowned newNext) {
        next = newNext;
    }

    transaction getKey(PendingPolicyList@HasNext this) returns Policy@Unowned {
        return key;
    }

    transaction getValue(PendingPolicyList@HasNext this) returns PolicyRecord@Unowned {
        PolicyRecord@Pending valCopy = val;
        val = valCopy;
        return valCopy;
    }

    transaction getValueCopy(PendingPolicyList@HasNext this) returns PolicyRecord@Pending {
        PolicyRecord@Pending valCopy = val;
        val = new PolicyRecord(val.getPolicy(), new Money(0));
        return valCopy;
    }


    transaction append(PendingPolicyList@Owned this, Policy@Unowned k, PolicyRecord@Pending >> Unowned v) {
        switch this {
            case HasNext {
                next.append(k, v);
            }
            case Empty {
                ->HasNext(key = k, val = v, next = new PendingPolicyList());
            }
        }
    }

    // get and remove the pair with the given Policy as a key
    transaction remove(PendingPolicyList@Owned this, Policy@Unowned policy, PendingPolicyList@HasNext prevNode) returns PolicyRecord@Pending {
        PolicyRecord@Pending removed;
        switch this {
            case Empty {
                throw; // TODO : element not in map?
            }
            case HasNext {
                if (key.equals(policy)) {
                    prevNode.setNext(next);
                    removed = getValueCopy();
                }
                else {
                    removed = next.remove(policy, this);
                }
            }
        }

        return removed;
    }
}


main resource contract PendingPolicyMap {
    PendingPolicyList@Owned list;

    PendingPolicyMap@Owned() {
        list = new PendingPolicyList(); // Start with an empty list.
    }

    transaction set(PendingPolicyMap@Owned this, Policy@Unowned key, PolicyRecord@Pending >> Unowned val) {
        list.append(key, val);
    }

    // remove and return value of the pair with the given policy as a key
    transaction extract(PendingPolicyMap@Owned this, Policy@Unowned policy) returns PolicyRecord@Pending {
        PolicyRecord@Pending removed;

        switch list {
            case HasNext {
                if(list.getKey().equals(policy)) {
                    removed = list.getValueCopy();
                    list = new PendingPolicyList();
                } else {
                    removed = list.remove(policy, list);
                }
            }
            case Empty {
                throw; //TODO : element not in map?
            }
        }

        return removed;

    }

}


