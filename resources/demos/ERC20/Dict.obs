import "Comparator.obs"

contract Option[asset T@s] {
    state None;
    asset state Some {
        T@s val;
    }

    Option@None() {
        ->None;
    }

    Option@Some(T@s >> Unowned v) {
        ->Some(val = v);
    }

    transaction unpack(Option[T@s]@Some >> None this) returns T@s {
        T result = val;
        ->None;
        return result;
    }
}




main contract Dict[KeyType, asset ValueType] {    
    state Empty;
    asset state HasNext;

    Dict[KeyType, ValueType]@(Empty | HasNext) next available in HasNext;
    KeyType@Unowned key available in HasNext, PrivateHasKeyAndValue;
    ValueType@Owned value available in HasNext, PrivateHasKeyAndValue, PrivateHasValue;

    Comparator[KeyType]@Unowned comparator;

    asset state PrivateHasKeyAndValue;
    asset state PrivateHasValue;

    Dict@Empty(Comparator@Unowned _comparator) {
        comparator = _comparator;
        ->Empty;
    }

    // Puts the given key/value pair into the dictionary.
    // If the key was already in the dictionary, returns an Option containing the old value.
    // Otherwise, returns None.
    transaction replace(Dict@(Empty | HasNext) this, KeyType@Unowned _key, ValueType@Owned >> Unowned _value) returns Option[ValueType@Owned]@Owned {
        switch this {
            case HasNext {
                if (comparator.equals(key, _key)) {
                    ValueType oldValue = value;
                    value = _value;
                    return new Option[ValueType@Owned](oldValue);
                }
                else {
                    return next.replace(_key, _value);
                }
            }
            case Empty {
                ->HasNext(key = _key, value = _value, next = new Dict[KeyType, ValueType](comparator));
                return new Option[ValueType@Owned]();
            }
        }
    }


    // Attempts to remove the key/value pair for the given key, returning the value. If the key is not found, returns None.
    transaction remove(Dict@(Empty | HasNext) this, KeyType@Unowned _key) returns Option[ValueType@Owned]@Owned {
        switch this {
            case HasNext {
                if (comparator.equals(key, _key)) {
                    
                    ValueType oldValue = value;
                    if (next in HasNext) {
                        Dict[KeyType, ValueType] newNext = next.extractNext();
                        KeyType newKey = next.extractKey();
                        ValueType newValue = next.extractValue();
                        // next is now Empty, so we can discard it implicitly.

                        ->HasNext(next = newNext, key = newKey, value = newValue);
                    }
                    else {
                        // next is already Empty. We're going to be empty too.
                        ->Empty;
                    }
                    
                    return new Option[ValueType@Owned](oldValue);

                }
                else {
                    return next.remove(_key);
                }
            }
            case Empty {
                return new Option[ValueType@Owned]();
            }
        }
    }

    private transaction extractNext(Dict@HasNext >> PrivateHasKeyAndValue this) returns Dict@(HasNext | Empty) {
        Dict[KeyType, ValueType] result = next;
        ->PrivateHasKeyAndValue;
        return result;
    }

    private transaction extractKey(Dict@PrivateHasKeyAndValue >> PrivateHasValue this) returns KeyType@Unowned {
        KeyType result = key;
        ->PrivateHasValue;
        return result;
    }

    private transaction extractValue(Dict@PrivateHasValue >> Empty this) returns ValueType@Owned {
        ValueType result = value;
        ->Empty;
        return result;
    }
    
    transaction peek (Dict@(Empty | HasNext) this, KeyType@Unowned _key) returns Option[ValueType@Unowned]@Owned {
         switch this {
            case HasNext {
                if (comparator.equals(key, _key)) {
                    return new Option[ValueType@Unowned](value);
                }
                else {
                    return next.peek(_key);
                }
            }
            case Empty {
                return new Option[ValueType@Unowned]();
            }
        }
    }

/*
    transaction find(Dict@Unowned this, int ownerAddress) returns T@Unowned {
        switch this {
            case HasNext {
                if (value.getOwnerAddress() == ownerAddress) {
                    return value;
                }
                else {
                    return next.find(obj);
                }
            }
            case Empty {
                revert "Can't find the given item.";
            }
        }
    }
    */

}
